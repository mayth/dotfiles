# load
autoload -U compinit && compinit
autoload -Uz vcs_info
autoload -Uz add-zsh-hook
autoload -Uz is-at-least
autoload -Uz colors

if [ -f ~/.zshrc.local ]; then
  source ~/.zshrc.local
fi

# bash compatibility
if [ -f ~/.bashrc ]; then
  source ~/.bashrc
fi

if [ -f ~/.bash_profile ]; then
  source ~/.bash_profile
fi

### key binding
bindkey -e

### misc
setopt no_beep
setopt hist_expand        # auto expand history in completion
setopt magic_equal_subst  # filename expand
REPORTTIME=30             # report the used time when the process used this time.

### directory moving
setopt auto_cd
setopt auto_pushd

### completion
zstyle ':completion:*' format '%B%d%b'
zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format '%U%B%d%b%u'
zstyle ':completion:*:warnings' format '%BSorry, no matches for: %d%b'
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:default' list-colors ""
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z} r:|[._-]=*'
zstyle ':completion:*' use-cache yes
zstyle ':completion:*' verbose yes
zstyle ':completion:sudo:*' environ PATH="$SUDO_PATH:$PATH"
zstyle ':completion:*' ignore-parents parent pwd ..

### history
# set history size
export HISTSIZE=2000
export HISTFILE="$HOME/.history"
export SAVEHIST=$HISTSIZE

# ignore duplicate commands and begin with space
setopt hist_ignorealldups
setopt hist_ignorespace

### enable extended-glob
setopt extendedglob

### path
# add sbin to path when completion with sudo
[ -z "$sudo_path" ] && typeset -xT SUDO_PATH sudo_path
typeset -U sudo_path
sudo_path=({,/usr,/usr/local}/sbin(N-/))

### grep
export GREP_OPTIONS
# GREP_OPTIONS="--binary-files=without-match --directories=recurse --exclude=\*.tmp --exclude-dir=.svn --exclude-dir=.git --exclude-dir=.deps --exclude-dir=.libs --color=auto"
GREP_OPTIONS="--binary-files=without-match --exclude=\*.tmp --exclude-dir=.svn --exclude-dir=.git --exclude-dir=.deps --exclude-dir=.libs --color=auto"

### Prompt setting
setopt prompt_subst
setopt transient_rprompt

default_rprompt="%F{green}[%d]%f"
case ${UID} in
# for root user
0)
  PROMPT="%B%F{yellow}%n@%m%k %B%F{blue}%c %# %b%f%k"
  PROMPT2="%B%F{yellow}%n@%m%k %B%F{blue}%c %_> %b%f%k"
  SPROMPT="zsh: correct '%R' to '%r' [No, Yes, Abort, Edit]?"
  [ -n "${REMOTEHOST}${SSH_CONNECTION}" ] &&
    PROMPT="%F{magenta}${HOST%%.*}$f ${PROMPT}"
  ;;
# for normal user
*)
  PROMPT="%B%F{green}%n@%m%k %B%F{blue}%c %# %b%f%k"
  PROMPT2="%B%F{green}%n@%m%k %B%F{blue}%c %_> %b%f%k"
  SPROMPT="zsh: correct %B'%R'%b to %B'%r'%b [No, Yes, Abort, Edit]? "
  [ -n "${REMOTEHOST}${SSH_CONNECTION}" ] &&
    PROMPT="%F{magenta}${HOST%%.*}%f ${PROMPT}"
  ;;
esac
### vcs_info
# http://qiita.com/items/8d5a627d773758dd8078

# Export messages
#   $vcs_info_msg_0_ : Normal (Green)
#   $vcs_info_msg_1_ : Warning (Yellow)
#   $vcs_info_msg_2_ : Error (Red)
zstyle ':vcs_info:*' max-exports 3

zstyle ':vcs_info:*' enable git svn hg bzr
# Normal format (for all except git)
# misc(%m) is replaced into empty string ordinally.
zstyle ':vcs_info:*' formats '(%s)-[%b]'
zstyle ':vcs_info:*' actionformats '(%s)-[%b]' '%m' '<!%a>'
zstyle ':vcs_info:(svn|bzr):*' branchformat '%b:r%r'
zstyle ':vcs_info:bzr:*' use-simple true


if is-at-least 4.3.10; then
    # format for git
    # show whether staged or not.
    zstyle ':vcs_info:git:*' formats '(%s)-[%b]' '%c%u %m'
    zstyle ':vcs_info:git:*' actionformats '(%s)-[%b]' '%c%u %m' '<!%a>'
    zstyle ':vcs_info:git:*' check-for-changes true
    zstyle ':vcs_info:git:*' stagedstr "+"    # string for %c
    zstyle ':vcs_info:git:*' unstagedstr "-"  # string for %u
fi

# hooks
if is-at-least 4.3.11; then
    # add hook functions for git

    # formats '(%s)-[%b]' '%c%u %m' , actionformats '(%s)-[%b]' '%c%u %m' '<!%a>'
    # hook before the message above
    # In this configuration, available messages is 2 for 'format' , 3 for 'actionformats',
    # so each functions are called 3 times at maximum.
    zstyle ':vcs_info:git+set-message:*' hooks \
                                            git-hook-begin \
                                            git-untracked \
                                            git-push-status \
                                            git-nomerge-branch \
                                            git-stash-count

    # First hook function
    # git の作業コピーのあるディレクトリのみフック関数を呼び出すようにする
    # hooks functions are called if there are working copy of git (not in .git directory)
    # because, for example, `git status --porcelain` will be failed, in .git directory.
    function +vi-git-hook-begin() {
        if [[ $(command git rev-parse --is-inside-work-tree 2> /dev/null) != 'true' ]]; then
            # hook functions after this will not be called if not 0 is returned.
            return 1
        fi

        return 0
    }

    # Showing untracked files
    #
    # Append '?' to `unstaged (%u)` if there are any untracked files.
    function +vi-git-untracked() {
        # targets 2nd message in zstyle formats, actionformats
        if [[ "$1" != "1" ]]; then
            return 0
        fi

        if command git status --porcelain 2> /dev/null \
            | awk '{print $1}' \
            | command grep -F '??' > /dev/null 2>&1 ; then

            # Append to unstaged (%u)
            hook_com[unstaged]+='?'
        fi
    }

    # Showing number of commits that aren't pushed yet.
    #
    # Append 'pN', N is a number of un-pushed commits, to `misc (%m)`
    function +vi-git-push-status() {
        # targets 2nd message in zstyle formats, actionformats
        if [[ "$1" != "1" ]]; then
            return 0
        fi

        if [[ "${hook_com[branch]}" != "master" ]]; then
            # Do nothing if it is not master branch
            return 0
        fi

        # get number of commits that un-pushed
        local ahead
        ahead=$(command git rev-list origin/master..master 2>/dev/null \
            | wc -l \
            | tr -d ' ')

        if [[ "$ahead" -gt 0 ]]; then
            # Append to misc (%m)
            hook_com[misc]+="(p${ahead})"
        fi
    }

    # Show unmerged commits
    #
    # Show mN in misc (%m). N is number of commits in current branch that is not merged to master.
    function +vi-git-nomerge-branch() {
        # targets 2nd message in zstyle formats, actionformats
        if [[ "$1" != "1" ]]; then
            return 0
        fi

        if [[ "${hook_com[branch]}" == "master" ]]; then
            # Do nothing if it is master branch
            return 0
        fi

        local nomerged
        nomerged=$(command git rev-list master..${hook_com[branch]} 2>/dev/null | wc -l | tr -d ' ')

        if [[ "$nomerged" -gt 0 ]] ; then
            # Append to misc (%m)
            hook_com[misc]+="(m${nomerged})"
        fi
    }


    # Show stashes
    #
    # Show :SN in misc (%m). N is a number of stashes
    function +vi-git-stash-count() {
        # targets 2nd message in zstyle formats, actionformats
        if [[ "$1" != "1" ]]; then
            return 0
        fi

        local stash
        stash=$(command git stash list 2>/dev/null | wc -l | tr -d ' ')
        if [[ "${stash}" -gt 0 ]]; then
            # Append to misc (%m)
            hook_com[misc]+=":S${stash}"
        fi
    }

fi

function _update_vcs_info_msg() {
    local -a messages
    local prompt

    LANG=en_US.UTF-8 vcs_info

    if [[ -z ${vcs_info_msg_0_} ]]; then
        # No prompt is shown if no information from vcs_info
        prompt="$default_rprompt"
    else
        # If there are some information from vcs_info, 
        # show $vcs_info_msg_0_ , $vcs_info_msg_1_ , $vcs_info_msg_2_
        [[ -n "$vcs_info_msg_0_" ]] && messages+=( "%F{green}${vcs_info_msg_0_}%f" )
        [[ -n "$vcs_info_msg_1_" ]] && messages+=( "%F{yellow}${vcs_info_msg_1_}%f" )
        [[ -n "$vcs_info_msg_2_" ]] && messages+=( "%F{red}${vcs_info_msg_2_}%f" )

        # concatenate them separated with space
        prompt="${(j: :)messages} $default_rprompt"
    fi

    RPROMPT="$prompt"
}
add-zsh-hook precmd _update_vcs_info_msg

### incremental search
if [ -f ~/.zsh/auto-fu.zsh ]; then
  source ~/.zsh/auto-fu.zsh
  function zle-line-init () {
    auto-fu-init
  }
  zle -N zle-line-init
  zstyle ':completion:*' completer _oldlist _complete
fi

### pager
if [ -n "${PAGER#lv}" ]; then
  export LV="-c -l" # -c to enable ASCII escape sequence coloring, -l to no line break in copying
fi


### user definition functions
# create new window on connecting with tmux&mosh
if [ $TERM = screen ]; then
  function mosh_tmux() {
    eval server=\${$#}
    tmux new-window -n $@ "exec ssh $@"
  }
  alias mosh=mosh_tmux
fi

# completion for mosh
function _mosh_hosts {
  local -a config_hosts
  local config
  integer ind

  # If users-hosts matches, we shouldn't complete anything else.
  if [[ "$IPREFIX" == *@ ]]; then
    _combination -s '[:@]' my-accounts users-hosts "users=${IPREFIX/@}" hosts "$@" && return
  else
    _combination -s '[:@]' my-accounts users-hosts \
      ${opt_args[-l]:+"users=${opt_args[-l]:q}"} hosts "$@" && return
  fi
  if (( ind = ${words[(I)-F]} )); then
    config=${~words[ind+1]}
  else
    config="$HOME/.ssh/config"
  fi
  if [[ -r $config ]]; then
    local IFS=$'\t ' key hosts host
    while read key hosts; do
      if [[ "$key" == (#i)host ]]; then
   for host in ${(z)hosts}; do
      case $host in
      (*[*?]*) ;;
      (*) config_hosts+=("$host") ;;
      esac
   done
      fi
    done < "$config"
    if (( ${#config_hosts} )); then
      _wanted hosts expl 'remote host name' \
  compadd -M 'm:{a-zA-Z}={A-Za-z} r:|.=* r:|=*' "$@" $config_hosts
    fi
  fi
}

compdef _mosh_hosts mosh

if [ -f ~/.zshrc.local.after ]; then
  source ~/.zshrc.local.after
fi

# Auto exec tmux
#if ( ! test $TMUX ) && ( ! expr $TERM : "^screen" > /dev/null ) && which tmux > /dev/null; then
#    if ( tmux has-session ); then
#        session=`tmux list-sessions | grep -e '^[0-9].*]$' | head -n 1 | sed -e 's/^\([0-9]\+\).*$/\1/'`
#            if [ -n "$session" ]; then
#            echo "Attache tmux session $session."
#                tmux attach-session -t $session
#        else
#            echo "Session has been already attached."
#            tmux list-sessions
#            fi
#    else
#        echo "Create new tmux session."
#        tmux
#    fi
#fi
